import { useState, useEffect, useCallback, useRef, useMemo } from 'react';
import type { FC, ChangeEvent, FormEvent } from 'react';
import { useSearchParams } from 'react-router-dom';
import { supabase } from '../lib/supabaseClient';

// Interfaces for our data models
interface Team {
    id: number;
    nombre: string;
}

interface Round {
    id: number;
    nombre: string;
}

interface Group {
    id: number;
    nombre: string;
    round_id: number;
}

interface TeamGroupAssignment {
    id?: number;
    team_id: number | null;
    group_id: number;
    round_id: number;
}

interface TeamSelectorProps {
    competitionId: string;
}

const TeamSelector: FC<TeamSelectorProps> = ({ competitionId }) => {
    const [searchParams, setSearchParams] = useSearchParams();
    const isMounted = useRef(true);

    // State
    const [teams, setTeams] = useState<Team[]>([]);
    const [rounds, setRounds] = useState<Round[]>([]);
    const [groups, setGroups] = useState<Group[]>([]);
    const [selectedRoundId, setSelectedRoundId] = useState<number | null>(null);
    const [selectedTeams, setSelectedTeams] = useState<Record<number, number | null>>({});
    const [isLoading, setIsLoading] = useState(true);
    const [error, setError] = useState<string>('');
    const [success, setSuccess] = useState<string>('');

    // Filter groups by selected round
    const filteredGroups = useMemo(() => {
        if (!selectedRoundId) return [];
        return groups.filter(group => group.round_id === selectedRoundId);
    }, [groups, selectedRoundId]);

    // Load team assignments for a specific round
    const loadAssignments = useCallback(async (roundId: number) => {
        try {
            const { data, error } = await supabase
                .from('equipos_grupos')
                .select('*')
                .eq('ronda_id', roundId);

            if (error) throw error;

            // Update selected teams state
            const assignments: Record<number, number | null> = {};
            data?.forEach((assignment: TeamGroupAssignment) => {
                if (assignment.group_id) {
                    assignments[assignment.group_id] = assignment.team_id;
                }
            });

            setSelectedTeams(assignments);
        } catch (err) {
            console.error('Error loading assignments:', err);
            setError('Error al cargar las asignaciones de equipos');
        }
    }, []);

    // Load data on component mount and when competitionId changes
    useEffect(() => {
        const loadData = async () => {
            if (!competitionId) return;
            
            setIsLoading(true);
            setError('');

            try {
                // Fetch teams, rounds, and groups in parallel
                const [
                    { data: teamsData, error: teamsError },
                    { data: roundsData, error: roundsError },
                    { data: groupsData, error: groupsError },
                ] = await Promise.all([
                    supabase
                        .from('equipos')
                        .select('*')
                        .eq('competencia_id', competitionId),
                    
                    supabase
                        .from('rondas')
                        .select('*')
                        .eq('competencia_id', competitionId)
                        .order('id'),
                    
                    supabase
                        .from('grupos')
                        .select('*')
                        .eq('competencia_id', competitionId)
                ]);

                if (teamsError) throw teamsError;
                if (roundsError) throw roundsError;
                if (groupsError) throw groupsError;

                if (isMounted.current) {
                    setTeams(teamsData || []);
                    setRounds(roundsData || []);
                    setGroups(groupsData || []);
                    
                    // If there's a round in the URL, select it
                    const urlRoundId = searchParams.get('round');
                    const initialRoundId = urlRoundId && roundsData?.some((r: Round) => r.id === parseInt(urlRoundId, 10))
                        ? parseInt(urlRoundId, 10)
                        : roundsData?.[0]?.id || null;
                    
                    setSelectedRoundId(initialRoundId);
                    
                    // If we have a round selected, load its assignments
                    if (initialRoundId) {
                        await loadAssignments(initialRoundId);
                    }
                }
            } catch (err) {
                console.error('Error loading data:', err);
                setError('Error al cargar los datos. Por favor intenta de nuevo.');
            } finally {
                if (isMounted.current) {
                    setIsLoading(false);
                }
            }
        };

        loadData();

        return () => {
            isMounted.current = false;
        };
    }, [competitionId, searchParams, loadAssignments]);

    // Handle team selection
    const handleTeamSelect = useCallback((groupId: number, teamId: number | null) => {
        setSelectedTeams(prev => ({
            ...prev,
            [groupId]: teamId
        }));
    }, []);

    // Handle round change
    const handleRoundChange = useCallback(async (e: React.ChangeEvent<HTMLSelectElement>) => {
        const roundId = parseInt(e.target.value, 10) || null;
        setSelectedRoundId(roundId);

        // Update URL
        const newSearchParams = new URLSearchParams(searchParams);
        if (roundId) {
            newSearchParams.set('round', roundId.toString());
        } else {
            newSearchParams.delete('round');
        }
        setSearchParams(newSearchParams);

        // Load assignments for the selected round
        if (roundId) {
            await loadAssignments(roundId);
        } else {
            setSelectedTeams({});
        }
    }, [searchParams, setSearchParams, loadAssignments]);

    // Handle form submission
    const handleSubmit = useCallback(async (e: FormEvent) => {
        e.preventDefault();
        
        if (!selectedRoundId) {
            setError('Por favor seleccione una ronda');
            return;
        }

        setIsLoading(true);
        setError('');
        setSuccess('');

        try {
            // Start a transaction
            const { error: transactionError } = await supabase.rpc('begin');
            if (transactionError) throw transactionError;

            // Delete existing assignments for this round
            const { error: deleteError } = await supabase
                .from('equipos_grupos')
                .delete()
                .eq('ronda_id', selectedRoundId);

            if (deleteError) throw deleteError;

            // Prepare new assignments (only include non-null team selections)
            const assignments = Object.entries(selectedTeams)
                .filter(([_, teamId]) => teamId !== null)
                .map(([groupId, teamId]) => ({
                    grupo_id: parseInt(groupId, 10),
                    equipo_id: teamId,
                    ronda_id: selectedRoundId,
                    competencia_id: parseInt(competitionId, 10)
                }));

            // Insert new assignments if any
            if (assignments.length > 0) {
                const { error: insertError } = await supabase
                    .from('equipos_grupos')
                    .insert(assignments);

                if (insertError) throw insertError;
            }

            // Commit transaction
            const { error: commitError } = await supabase.rpc('commit');
            if (commitError) throw commitError;

            setSuccess('Asignaciones guardadas correctamente');
        } catch (err) {
            // Rollback on error
            await supabase.rpc('rollback');
            setError('Error al guardar las asignaciones');
            console.error('Error saving assignments:', err);
        } finally {
            setIsLoading(false);
        }
    }, [competitionId, selectedRoundId, selectedTeams]);

    if (!competitionId) {
        return (
            <div className="p-4 text-red-500">
                Error: No se ha especificado una competencia
            </div>
        );
    }

    return (
        <div className="container mx-auto px-4 py-8">
            <h1 className="text-2xl font-bold mb-6">Asignaci√≥n de Equipos</h1>
            
            {error && (
                <div className="mb-4 p-4 bg-red-100 border border-red-400 text-red-700 rounded">
                    {error}
                </div>
            )}
            
            {success && (
                <div className="mb-4 p-4 bg-green-100 border border-green-400 text-green-700 rounded">
                    {success}
                </div>
            )}
            
            {/* Round Selection */}
            <div className="mb-6">
                <label htmlFor="round-select" className="block text-sm font-medium text-gray-700 mb-2">
                    Seleccionar Ronda:
                </label>
                <select
                    id="round-select"
                    value={selectedRoundId || ''}
                    onChange={handleRoundChange}
                    className="block w-full pl-3 pr-10 py-2 text-base border-gray-300 focus:outline-none focus:ring-blue-500 focus:border-blue-500 sm:text-sm rounded-md"
                    disabled={isLoading || rounds.length === 0}
                >
                    <option value="">Seleccione una ronda</option>
                    {rounds.map(round => (
                        <option key={round.id} value={round.id}>
                            {round.nombre}
                        </option>
                    ))}
                </select>
            </div>
            
            {/* Groups and Team Selection */}
            {selectedRoundId && (
                <div className="mt-8">
                    <h2 className="text-xl font-semibold mb-4">Grupos</h2>
                    <div className="grid grid-cols-1 md:grid-cols-2 lg:grid-cols-3 gap-6">
                        {filteredGroups.map(group => (
                            <div key={group.id} className="border rounded-lg p-4 shadow-sm">
                                <h3 className="font-medium text-lg mb-3">{group.nombre}</h3>
                                <select
                                    value={selectedTeams[group.id] || ''}
                                    onChange={(e) => handleTeamSelect(
                                        group.id, 
                                        e.target.value ? parseInt(e.target.value, 10) : null
                                    )}
                                    className="block w-full pl-3 pr-10 py-2 text-base border-gray-300 focus:outline-none focus:ring-blue-500 focus:border-blue-500 sm:text-sm rounded-md"
                                    disabled={isLoading}
                                >
                                    <option value="">Seleccione un equipo</option>
                                    {teams.map(team => (
                                        <option key={team.id} value={team.id}>
                                            {team.nombre}
                                        </option>
                                    ))}
                                </select>
                            </div>
                        ))}
                    </div>
                    
                    {/* Submit Button */}
                    <div className="mt-8">
                        <button
                            type="button"
                            onClick={handleSubmit}
                            disabled={isLoading}
                            className={`inline-flex items-center px-4 py-2 border border-transparent text-sm font-medium rounded-md shadow-sm text-white ${
                                isLoading ? 'bg-gray-400' : 'bg-blue-600 hover:bg-blue-700'
                            } focus:outline-none focus:ring-2 focus:ring-offset-2 focus:ring-blue-500`}
                        >
                            {isLoading ? 'Guardando...' : 'Guardar asignaciones'}
                        </button>
                    </div>
                </div>
            )}
        </div>
    );
};

export default TeamSelector;
